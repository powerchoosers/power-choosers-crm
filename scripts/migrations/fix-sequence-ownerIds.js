/**
 * One-Time Migration Script: Fix ownerId fields in sequences and sequenceMembers
 * 
 * This script fixes existing sequences and sequenceMembers documents that are missing
 * or have incorrect ownerId, createdBy, and assignedTo fields.
 * 
 * TO RUN: Copy and paste this entire script into your browser console, then call:
 *   await migrateSequenceOwnerIds()
 * 
 * The script will:
 * 1. Find all sequences missing ownerId fields or with incorrect patterns
 * 2. Find all sequenceMembers missing ownerId fields
 * 3. Update them with the correct ownerId pattern (matching sequences.js)
 * 4. Show progress and results
 */

async function migrateSequenceOwnerIds() {
  console.log('üöÄ Starting sequence ownerId migration...');
  console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
  
  try {
    const db = window.firebaseDB;
    if (!db) {
      console.error('‚ùå Firebase database not available. Make sure Firebase is initialized.');
      return { success: false, error: 'Firebase not available' };
    }

    // Get current user email using the same method as sequences.js
    const userEmail = (window.DataManager && typeof window.DataManager.getCurrentUserEmail === 'function')
      ? window.DataManager.getCurrentUserEmail()
      : ((window.currentUserEmail || '').toLowerCase());

    if (!userEmail || userEmail === 'unknown') {
      console.error('‚ùå Could not determine user email. Please ensure you are logged in.');
      return { success: false, error: 'User email not available' };
    }

    console.log(`üë§ Current user email: ${userEmail}`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

    const results = {
      sequences: { updated: 0, skipped: 0, errors: 0 },
      sequenceMembers: { updated: 0, skipped: 0, errors: 0 }
    };

    // ===== MIGRATE SEQUENCES =====
    console.log('üìã Step 1: Migrating sequences collection...');
    try {
      const sequencesSnapshot = await db.collection('sequences').get();
      console.log(`   Found ${sequencesSnapshot.size} sequences to check`);

      const updatePromises = [];
      
      sequencesSnapshot.forEach(doc => {
        const data = doc.data();
        const id = doc.id;
        
        // Check if ownerId needs updating
        const needsUpdate = !data.ownerId || 
                           data.ownerId !== userEmail ||
                           !data.createdBy ||
                           data.createdBy !== userEmail ||
                           !data.assignedTo ||
                           data.assignedTo !== userEmail;

        if (!needsUpdate) {
          results.sequences.skipped++;
          return;
        }

        // Prepare update
        const updateData = {
          ownerId: userEmail,
          createdBy: data.createdBy || userEmail,
          assignedTo: data.assignedTo || userEmail
        };

        // Use server timestamp if available
        if (window.firebase?.firestore?.FieldValue?.serverTimestamp) {
          updateData.updatedAt = window.firebase.firestore.FieldValue.serverTimestamp();
        } else {
          updateData.updatedAt = Date.now();
        }

        // Add to batch
        updatePromises.push(
          db.collection('sequences').doc(id).update(updateData)
            .then(() => {
              results.sequences.updated++;
              console.log(`   ‚úÖ Updated sequence: ${id} (${data.name || 'unnamed'})`);
            })
            .catch(err => {
              results.sequences.errors++;
              console.error(`   ‚ùå Error updating sequence ${id}:`, err);
            })
        );
      });

      await Promise.all(updatePromises);
      console.log(`   ‚úì Sequences migration complete: ${results.sequences.updated} updated, ${results.sequences.skipped} skipped, ${results.sequences.errors} errors\n`);

    } catch (error) {
      console.error('‚ùå Error migrating sequences:', error);
      results.sequences.errors++;
    }

    // ===== MIGRATE SEQUENCE MEMBERS =====
    console.log('üë• Step 2: Migrating sequenceMembers collection...');
    try {
      const membersSnapshot = await db.collection('sequenceMembers').get();
      console.log(`   Found ${membersSnapshot.size} sequenceMembers to check`);

      const updatePromises = [];
      
      membersSnapshot.forEach(doc => {
        const data = doc.data();
        const id = doc.id;
        
        // Check if ownerId fields need updating
        const needsUpdate = !data.ownerId || 
                           data.ownerId !== userEmail ||
                           !data.createdBy ||
                           data.createdBy !== userEmail ||
                           !data.assignedTo ||
                           data.assignedTo !== userEmail;

        if (!needsUpdate) {
          results.sequenceMembers.skipped++;
          return;
        }

        // Prepare update
        const updateData = {
          ownerId: userEmail,
          createdBy: data.createdBy || userEmail,
          assignedTo: data.assignedTo || userEmail
        };

        // Use server timestamp if available
        if (window.firebase?.firestore?.FieldValue?.serverTimestamp) {
          updateData.updatedAt = window.firebase.firestore.FieldValue.serverTimestamp();
        } else {
          updateData.updatedAt = Date.now();
        }

        // Add to batch
        updatePromises.push(
          db.collection('sequenceMembers').doc(id).update(updateData)
            .then(() => {
              results.sequenceMembers.updated++;
              if (results.sequenceMembers.updated % 10 === 0) {
                console.log(`   ‚úÖ Updated ${results.sequenceMembers.updated} sequenceMembers...`);
              }
            })
            .catch(err => {
              results.sequenceMembers.errors++;
              console.error(`   ‚ùå Error updating sequenceMember ${id}:`, err);
            })
        );
      });

      await Promise.all(updatePromises);
      console.log(`   ‚úì SequenceMembers migration complete: ${results.sequenceMembers.updated} updated, ${results.sequenceMembers.skipped} skipped, ${results.sequenceMembers.errors} errors\n`);

    } catch (error) {
      console.error('‚ùå Error migrating sequenceMembers:', error);
      results.sequenceMembers.errors++;
    }

    // ===== FIX RECORD COUNTS =====
    console.log('üìä Step 3: Fixing recordCount fields in sequences...');
    try {
      const sequencesSnapshot = await db.collection('sequences').get();
      let countFixed = 0;

      const countPromises = [];
      
      sequencesSnapshot.forEach(async (seqDoc) => {
        const seqData = seqDoc.data();
        const seqId = seqDoc.id;

        // Count actual sequenceMembers
        const membersQuery = await db.collection('sequenceMembers')
          .where('sequenceId', '==', seqId)
          .where('targetType', '==', 'people')
          .get();

        const actualCount = membersQuery.size;

        // Check if recordCount is wrong
        if (seqData.recordCount !== actualCount) {
          const updateData = {
            recordCount: actualCount
          };

          if (window.firebase?.firestore?.FieldValue?.serverTimestamp) {
            updateData.updatedAt = window.firebase.firestore.FieldValue.serverTimestamp();
          } else {
            updateData.updatedAt = Date.now();
          }

          countPromises.push(
            db.collection('sequences').doc(seqId).update(updateData)
              .then(() => {
                countFixed++;
                console.log(`   ‚úÖ Fixed recordCount for sequence ${seqId}: ${seqData.recordCount || 0} ‚Üí ${actualCount}`);
              })
              .catch(err => {
                console.error(`   ‚ùå Error fixing recordCount for ${seqId}:`, err);
              })
          );
        }
      });

      await Promise.all(countPromises);
      console.log(`   ‚úì Fixed ${countFixed} recordCount values\n`);

    } catch (error) {
      console.error('‚ùå Error fixing recordCounts:', error);
    }

    // ===== SUMMARY =====
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log('‚ú® Migration Complete!');
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ');
    console.log(`üìã Sequences: ${results.sequences.updated} updated, ${results.sequences.skipped} skipped, ${results.sequences.errors} errors`);
    console.log(`üë• SequenceMembers: ${results.sequenceMembers.updated} updated, ${results.sequenceMembers.skipped} skipped, ${results.sequenceMembers.errors} errors`);
    console.log('‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n');

    if (results.sequences.errors > 0 || results.sequenceMembers.errors > 0) {
      console.warn('‚ö†Ô∏è  Some errors occurred during migration. Check the output above for details.');
    } else {
      console.log('‚úÖ All migrations completed successfully!');
    }

    return {
      success: true,
      results: results
    };

  } catch (error) {
    console.error('‚ùå Migration failed:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

// Export for console use
window.migrateSequenceOwnerIds = migrateSequenceOwnerIds;

console.log('üìù Migration script loaded!');
console.log('üí° To run: await migrateSequenceOwnerIds()');

